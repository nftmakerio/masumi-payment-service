// This file is auto-generated by @hey-api/openapi-ts

export type GetHealthData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/health/';
};

export type GetHealthResponses = {
  /**
   * Object with status ok, if the server is running
   */
  200: {
    status: string;
  };
};

export type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses];

export type GetApiKeyStatusData = {
  body?: never;
  path?: never;
  query?: never;
  url: '/api-key-status/';
};

export type GetApiKeyStatusResponses = {
  /**
   * API key status
   */
  200: {
    status: string;
    data: {
      token: string;
      permission: 'Read' | 'ReadAndPay' | 'Admin';
      usageLimited: boolean;
      networkLimit: Array<'Preprod' | 'Mainnet'>;
      RemainingUsageCredits: Array<{
        unit: string;
        amount: string;
      }>;
      status: 'Active' | 'Revoked';
    };
  };
};

export type GetApiKeyStatusResponse =
  GetApiKeyStatusResponses[keyof GetApiKeyStatusResponses];

export type GetWalletData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The type of wallet to query
     */
    walletType: 'Selling' | 'Purchasing';
    /**
     * The id of the wallet to query
     */
    id: string;
    /**
     * Whether to include the decrypted secret in the response
     */
    includeSecret?: string;
  };
  url: '/wallet/';
};

export type GetWalletResponses = {
  /**
   * Wallet status
   */
  200: {
    status: string;
    data: {
      Secret?: {
        createdAt: string;
        updatedAt: string;
        mnemonic: string;
      };
      PendingTransaction: {
        createdAt: string;
        updatedAt: string;
        hash: string | null;
        lastCheckedAt: string | null;
      } | null;
      note: string | null;
      walletVkey: string;
      walletAddress: string;
    };
  };
};

export type GetWalletResponse = GetWalletResponses[keyof GetWalletResponses];

export type PostWalletData = {
  body?: {
    /**
     * The network the Cardano wallet will be used on
     */
    network: 'Preprod' | 'Mainnet';
  };
  path?: never;
  query?: never;
  url: '/wallet/';
};

export type PostWalletResponses = {
  /**
   * Wallet created
   */
  200: {
    walletMnemonic: string;
    walletAddress: string;
    walletVkey: string;
  };
};

export type PostWalletResponse = PostWalletResponses[keyof PostWalletResponses];

export type DeleteApiKeyData = {
  body?: {
    /**
     * The id of the API key to delete. Provide either id or apiKey
     */
    id?: string;
    /**
     * The API key to delete. Provide either id or apiKey
     */
    token?: string;
  };
  path?: never;
  query?: never;
  url: '/api-key/';
};

export type DeleteApiKeyErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type DeleteApiKeyResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      id: string;
      token: string;
    };
    status: string;
  };
};

export type DeleteApiKeyResponse =
  DeleteApiKeyResponses[keyof DeleteApiKeyResponses];

export type GetApiKeyData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The number of API keys to return
     */
    limit?: number;
    /**
     * Used to paginate through the API keys
     */
    cursorApiKey?: string;
  };
  url: '/api-key/';
};

export type GetApiKeyErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetApiKeyResponses = {
  /**
   * Api key status
   */
  200: {
    status: string;
    data: {
      apiKeys: Array<{
        token: string;
        permission: 'Read' | 'ReadAndPay' | 'Admin';
        usageLimited: boolean;
        networkLimit: Array<'Preprod' | 'Mainnet'>;
        RemainingUsageCredits: Array<{
          unit: string;
          amount: string;
        }>;
        status: 'Active' | 'Revoked';
      }>;
    };
  };
};

export type GetApiKeyResponse = GetApiKeyResponses[keyof GetApiKeyResponses];

export type PatchApiKeyData = {
  body?: {
    /**
     * The id of the API key to update. Provide either id or apiKey
     */
    id?: string;
    /**
     * The API key to update. Provide either id or apiKey
     */
    token?: string;
    /**
     * The remaining credits allowed to be used by the API key. Only relevant if usageLimited is true.
     */
    UsageCredits?: Array<{
      unit: string;
      amount: string;
    }>;
    /**
     * The status of the API key
     */
    status?: 'Active' | 'Revoked';
    /**
     * The networks the API key is allowed to use
     */
    networkLimit?: Array<'Preprod' | 'Mainnet'>;
  };
  path?: never;
  query?: never;
  url: '/api-key/';
};

export type PatchApiKeyErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PatchApiKeyResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      id: string;
      token: string;
      permission: 'Read' | 'ReadAndPay' | 'Admin';
      networkLimit: Array<'Preprod' | 'Mainnet'>;
      usageLimited: boolean;
      status: 'Active' | 'Revoked';
    };
    status: string;
  };
};

export type PatchApiKeyResponse =
  PatchApiKeyResponses[keyof PatchApiKeyResponses];

export type PostApiKeyData = {
  body?: {
    /**
     * Whether the API key is usage limited. Meaning only allowed to use the specified credits or can freely spend
     */
    usageLimited?: string;
    /**
     * The credits allowed to be used by the API key. Only relevant if usageLimited is true.
     */
    UsageCredits: Array<{
      unit: string;
      amount: string;
    }>;
    /**
     * The networks the API key is allowed to use
     */
    networkLimit?: Array<'Preprod' | 'Mainnet'>;
    /**
     * The permission of the API key
     */
    permission?: 'Read' | 'ReadAndPay' | 'Admin';
  };
  path?: never;
  query?: never;
  url: '/api-key/';
};

export type PostApiKeyErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostApiKeyResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      id: string;
      token: string;
      permission: 'Read' | 'ReadAndPay' | 'Admin';
      usageLimited: boolean;
      networkLimit: Array<'Preprod' | 'Mainnet'>;
      status: 'Active' | 'Revoked';
    };
    status: string;
  };
};

export type PostApiKeyResponse = PostApiKeyResponses[keyof PostApiKeyResponses];

export type GetPaymentData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The number of payments to return
     */
    limit?: number;
    /**
     * Used to paginate through the payments. If this is provided, cursorId is required
     */
    cursorId?: string;
    /**
     * The network the payments were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The address of the smart contract where the payments were made to
     */
    smartContractAddress?: string;
    /**
     * Whether to include the full transaction and status history of the payments
     */
    includeHistory?: string;
  };
  url: '/payment/';
};

export type GetPaymentErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPaymentResponses = {
  /**
   * Payment status
   */
  200: {
    status: string;
    data: {
      payments: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        blockchainIdentifier: string;
        lastCheckedAt: string | null;
        submitResultTime: string;
        unlockTime: string;
        externalDisputeUnlockTime: string;
        requestedById: string;
        resultHash: string;
        cooldownTime: number;
        cooldownTimeOtherParty: number;
        onChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        NextAction: {
          requestedAction:
            | 'None'
            | 'Ignore'
            | 'WaitingForManualAction'
            | 'WaitingForExternalAction'
            | 'SubmitResultRequested'
            | 'SubmitResultInitiated'
            | 'WithdrawRequested'
            | 'WithdrawInitiated'
            | 'AuthorizeRefundRequested'
            | 'AuthorizeRefundInitiated';
          errorType: 'NetworkError' | 'Unknown';
          errorNote: string | null;
        };
        CurrentTransaction: {
          id: string;
          createdAt: string;
          updatedAt: string;
          txHash: string | null;
        } | null;
        TransactionHistory: Array<{
          id: string;
          createdAt: string;
          updatedAt: string;
          txHash: string | null;
        }> | null;
        Amounts: Array<{
          id: string;
          createdAt: string;
          updatedAt: string;
          amount: string;
          unit: string;
        }>;
        PaymentSource: {
          id: string;
          network: 'Preprod' | 'Mainnet';
          smartContractAddress: string;
          paymentType: 'Web3CardanoV1';
        };
        BuyerWallet: {
          id: string;
          walletVkey: string;
        } | null;
        SmartContractWallet: {
          id: string;
          walletVkey: string;
          walletAddress: string;
        } | null;
        metadata: string | null;
      }>;
    };
  };
};

export type GetPaymentResponse = GetPaymentResponses[keyof GetPaymentResponses];

export type PostPaymentData = {
  body?: {
    /**
     * The network the payment will be received on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The identifier of the agent that will be paid
     */
    agentIdentifier: string;
    /**
     * The amounts of the payment
     */
    amounts: Array<{
      amount: string;
      unit: string;
    }>;
    /**
     * The type of payment contract used
     */
    paymentType: 'Web3CardanoV1';
    /**
     * The address of the smart contract where the payment will be made to
     */
    smartContractAddress?: string;
    /**
     * The time after which the payment has to be submitted to the smart contract
     */
    submitResultTime?: Date;
    /**
     * The time after which the payment will be unlocked
     */
    unlockTime?: Date;
    /**
     * The time after which the payment will be unlocked for external dispute
     */
    externalDisputeUnlockTime?: Date;
    /**
     * Metadata to be stored with the payment request
     */
    metadata?: string;
    /**
     * The cuid2 identifier of the purchaser of the payment
     */
    identifierFromPurchaser: string;
  };
  path?: never;
  query?: never;
  url: '/payment/';
};

export type PostPaymentErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPaymentResponses = {
  /**
   * Payment request created
   */
  200: {
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      lastCheckedAt: string | null;
      requestedById: string;
      resultHash: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'SubmitResultRequested'
          | 'SubmitResultInitiated'
          | 'WithdrawRequested'
          | 'WithdrawInitiated'
          | 'AuthorizeRefundRequested'
          | 'AuthorizeRefundInitiated';
        errorType: 'NetworkError' | 'Unknown';
        errorNote: string | null;
      };
      Amounts: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
      };
      BuyerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPaymentResponse =
  PostPaymentResponses[keyof PostPaymentResponses];

export type PostPaymentSubmitResultData = {
  body?: {
    /**
     * The network the payment was received on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The address of the smart contract where the payment was made to
     */
    smartContractAddress?: string;
    /**
     * The hash of the AI agent result to be submitted
     */
    submitResultHash: string;
    /**
     * The identifier of the payment
     */
    blockchainIdentifier: string;
  };
  path?: never;
  query?: never;
  url: '/payment/submit-result';
};

export type PostPaymentSubmitResultErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPaymentSubmitResultResponses = {
  /**
   * Payment updated
   */
  200: {
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      lastCheckedAt: string | null;
      requestedById: string;
      resultHash: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'SubmitResultRequested'
          | 'SubmitResultInitiated'
          | 'WithdrawRequested'
          | 'WithdrawInitiated'
          | 'AuthorizeRefundRequested'
          | 'AuthorizeRefundInitiated';
        errorType: 'NetworkError' | 'Unknown';
        errorNote: string | null;
      };
      Amounts: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
      };
      BuyerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPaymentSubmitResultResponse =
  PostPaymentSubmitResultResponses[keyof PostPaymentSubmitResultResponses];

export type PostPaymentAuthorizeRefundData = {
  body?: {
    /**
     * The identifier of the purchase to be refunded
     */
    blockchainIdentifier: string;
    /**
     * The network the Cardano wallet will be used on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The address of the smart contract holding the purchase
     */
    paymentContractAddress?: string;
  };
  path?: never;
  query?: never;
  url: '/payment/authorize-refund';
};

export type PostPaymentAuthorizeRefundErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPaymentAuthorizeRefundResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      lastCheckedAt: string | null;
      requestedById: string;
      resultHash: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'SubmitResultRequested'
          | 'SubmitResultInitiated'
          | 'WithdrawRequested'
          | 'WithdrawInitiated'
          | 'AuthorizeRefundRequested'
          | 'AuthorizeRefundInitiated';
        errorType: 'NetworkError' | 'Unknown';
        errorNote: string | null;
      };
      Amounts: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
      };
      BuyerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPaymentAuthorizeRefundResponse =
  PostPaymentAuthorizeRefundResponses[keyof PostPaymentAuthorizeRefundResponses];

export type GetPurchaseData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The number of purchases to return
     */
    limit?: number;
    /**
     * Used to paginate through the purchases. If this is provided, cursorId is required
     */
    cursorId?: string;
    /**
     * The network the purchases were made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The address of the smart contract where the purchases were made to
     */
    smartContractAddress?: string;
    /**
     * Whether to include the full transaction and status history of the purchases
     */
    includeHistory?: string;
  };
  url: '/purchase/';
};

export type GetPurchaseErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type GetPurchaseResponses = {
  /**
   * Purchase status
   */
  200: {
    status: string;
    data: {
      purchases: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        blockchainIdentifier: string;
        lastCheckedAt: string | null;
        submitResultTime: string;
        unlockTime: string;
        externalDisputeUnlockTime: string;
        requestedById: string;
        onChainState:
          | 'FundsLocked'
          | 'FundsOrDatumInvalid'
          | 'ResultSubmitted'
          | 'RefundRequested'
          | 'Disputed'
          | 'Withdrawn'
          | 'RefundWithdrawn'
          | 'DisputedWithdrawn';
        cooldownTime: number;
        cooldownTimeOtherParty: number;
        resultHash: string;
        NextAction: {
          requestedAction:
            | 'None'
            | 'Ignore'
            | 'WaitingForManualAction'
            | 'WaitingForExternalAction'
            | 'FundsLockingRequested'
            | 'FundsLockingInitiated'
            | 'SetRefundRequestedRequested'
            | 'SetRefundRequestedInitiated'
            | 'UnSetRefundRequestedRequested'
            | 'UnSetRefundRequestedInitiated'
            | 'WithdrawRefundRequested'
            | 'WithdrawRefundInitiated';
          errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
          errorNote: string | null;
        };
        CurrentTransaction: {
          id: string;
          createdAt: string;
          updatedAt: string;
          txHash: string;
          status: 'Pending' | 'Confirmed' | 'FailedViaTimeout';
        } | null;
        TransactionHistory: Array<{
          id: string;
          createdAt: string;
          updatedAt: string;
          txHash: string;
          status: 'Pending' | 'Confirmed' | 'FailedViaTimeout';
        }>;
        Amounts: Array<{
          id: string;
          createdAt: string;
          updatedAt: string;
          amount: string;
          unit: string;
        }>;
        PaymentSource: {
          id: string;
          network: 'Preprod' | 'Mainnet';
          smartContractAddress: string;
          paymentType: 'Web3CardanoV1';
        };
        SellerWallet: {
          id: string;
          walletVkey: string;
        } | null;
        SmartContractWallet: {
          id: string;
          walletVkey: string;
          walletAddress: string;
        } | null;
        metadata: string | null;
      }>;
    };
  };
};

export type GetPurchaseResponse =
  GetPurchaseResponses[keyof GetPurchaseResponses];

export type PostPurchaseData = {
  body?: {
    /**
     * The identifier of the purchase. Is provided by the seller
     */
    blockchainIdentifier: string;
    /**
     * The network the transaction will be made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The verification key of the seller
     */
    sellerVkey: string;
    /**
     * The identifier of the agent that is being purchased
     */
    agentIdentifier: string;
    /**
     * The address of the smart contract where the purchase will be made to
     */
    smartContractAddress?: string;
    /**
     * The amounts of the purchase
     */
    amounts: Array<{
      amount: string;
      unit: string;
    }>;
    /**
     * The payment type of smart contract used
     */
    paymentType: 'Web3CardanoV1';
    /**
     * The time after which the purchase will be unlocked. In unix time (number)
     */
    unlockTime: string;
    /**
     * The time after which the purchase will be unlocked for external dispute. In unix time (number)
     */
    externalDisputeUnlockTime: string;
    /**
     * The time by which the result has to be submitted. In unix time (number)
     */
    submitResultTime: string;
    /**
     * Metadata to be stored with the purchase request
     */
    metadata?: string;
    /**
     * The cuid2 identifier of the purchaser of the purchase
     */
    identifierFromPurchaser: string;
  };
  path?: never;
  query?: never;
  url: '/purchase/';
};

export type PostPurchaseErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPurchaseResponses = {
  /**
   * Purchase request created
   */
  200: {
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      lastCheckedAt: string | null;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      requestedById: string;
      resultHash: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'FundsLockingRequested'
          | 'FundsLockingInitiated'
          | 'SetRefundRequestedRequested'
          | 'SetRefundRequestedInitiated'
          | 'UnSetRefundRequestedRequested'
          | 'UnSetRefundRequestedInitiated'
          | 'WithdrawRefundRequested'
          | 'WithdrawRefundInitiated';
        errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
        errorNote: string | null;
      };
      CurrentTransaction: {
        id: string;
        createdAt: string;
        updatedAt: string;
        txHash: string;
        status: 'Pending' | 'Confirmed' | 'FailedViaTimeout';
      } | null;
      Amounts: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
      };
      SellerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPurchaseResponse =
  PostPurchaseResponses[keyof PostPurchaseResponses];

export type PostPurchaseRequestRefundData = {
  body?: {
    /**
     * The identifier of the purchase to be refunded
     */
    blockchainIdentifier: string;
    /**
     * The network the Cardano wallet will be used on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The address of the smart contract holding the purchase
     */
    smartContractAddress?: string;
  };
  path?: never;
  query?: never;
  url: '/purchase/request-refund';
};

export type PostPurchaseRequestRefundErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPurchaseRequestRefundResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      lastCheckedAt: string | null;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      requestedById: string;
      resultHash: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'FundsLockingRequested'
          | 'FundsLockingInitiated'
          | 'SetRefundRequestedRequested'
          | 'SetRefundRequestedInitiated'
          | 'UnSetRefundRequestedRequested'
          | 'UnSetRefundRequestedInitiated'
          | 'WithdrawRefundRequested'
          | 'WithdrawRefundInitiated';
        errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
        errorNote: string | null;
      };
      CurrentTransaction: {
        id: string;
        createdAt: string;
        updatedAt: string;
        txHash: string;
        status: 'Pending' | 'Confirmed' | 'FailedViaTimeout';
      } | null;
      Amounts: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
      };
      SellerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPurchaseRequestRefundResponse =
  PostPurchaseRequestRefundResponses[keyof PostPurchaseRequestRefundResponses];

export type PostPurchaseCancelRefundRequestData = {
  body?: {
    /**
     * The identifier of the purchase to be refunded
     */
    blockchainIdentifier: string;
    /**
     * The network the Cardano wallet will be used on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The address of the smart contract holding the purchase
     */
    smartContractAddress?: string;
  };
  path?: never;
  query?: never;
  url: '/purchase/cancel-refund-request';
};

export type PostPurchaseCancelRefundRequestErrors = {
  /**
   * Bad Request (possible parameters missing or invalid)
   */
  400: unknown;
  /**
   * Unauthorized
   */
  401: unknown;
  /**
   * Internal Server Error
   */
  500: unknown;
};

export type PostPurchaseCancelRefundRequestResponses = {
  /**
   * API key deleted
   */
  200: {
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      blockchainIdentifier: string;
      lastCheckedAt: string | null;
      submitResultTime: string;
      unlockTime: string;
      externalDisputeUnlockTime: string;
      requestedById: string;
      resultHash: string;
      onChainState:
        | 'FundsLocked'
        | 'FundsOrDatumInvalid'
        | 'ResultSubmitted'
        | 'RefundRequested'
        | 'Disputed'
        | 'Withdrawn'
        | 'RefundWithdrawn'
        | 'DisputedWithdrawn';
      NextAction: {
        requestedAction:
          | 'None'
          | 'Ignore'
          | 'WaitingForManualAction'
          | 'WaitingForExternalAction'
          | 'FundsLockingRequested'
          | 'FundsLockingInitiated'
          | 'SetRefundRequestedRequested'
          | 'SetRefundRequestedInitiated'
          | 'UnSetRefundRequestedRequested'
          | 'UnSetRefundRequestedInitiated'
          | 'WithdrawRefundRequested'
          | 'WithdrawRefundInitiated';
        errorType: 'NetworkError' | 'InsufficientFunds' | 'Unknown';
        errorNote: string | null;
      };
      CurrentTransaction: {
        id: string;
        createdAt: string;
        updatedAt: string;
        txHash: string;
        status: 'Pending' | 'Confirmed' | 'FailedViaTimeout';
      } | null;
      Amounts: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        amount: string;
        unit: string;
      }>;
      PaymentSource: {
        id: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
      };
      SellerWallet: {
        id: string;
        walletVkey: string;
      } | null;
      SmartContractWallet: {
        id: string;
        walletVkey: string;
        walletAddress: string;
      } | null;
      metadata: string | null;
    };
    status: string;
  };
};

export type PostPurchaseCancelRefundRequestResponse =
  PostPurchaseCancelRefundRequestResponses[keyof PostPurchaseCancelRefundRequestResponses];

export type DeleteRegistryData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The identifier of the registration (asset) to be deregistered
     */
    assetName: string;
    /**
     * The network the registration was made on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment contract to which the registration belongs
     */
    smartContractAddress?: string;
  };
  url: '/registry/';
};

export type DeleteRegistryResponses = {
  /**
   * Payment source deleted
   */
  200: {
    status: string;
    data: {
      name: string;
      api_url: string;
      capability_name: string;
      capability_version: string;
      description: string | null;
      requests_per_hour: string | null;
      privacy_policy: string | null;
      terms: string | null;
      other: string | null;
      tags: Array<string>;
      SmartContractWallet: {
        walletVkey: string;
        walletAddress: string;
      };
      state:
        | 'RegistrationRequested'
        | 'RegistrationInitiated'
        | 'RegistrationConfirmed'
        | 'RegistrationFailed'
        | 'DeregistrationRequested'
        | 'DeregistrationInitiated'
        | 'DeregistrationConfirmed'
        | 'DeregistrationFailed';
      Pricing: Array<{
        unit: string;
        quantity: string;
      }>;
    };
  };
};

export type DeleteRegistryResponse =
  DeleteRegistryResponses[keyof DeleteRegistryResponses];

export type GetRegistryData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The payment key of the wallet to be queried
     */
    walletVKey: string;
    /**
     * The Cardano network used to register the agent on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment source to which the registration belongs
     */
    smartContractAddress?: string;
  };
  url: '/registry/';
};

export type GetRegistryResponses = {
  /**
   * Agent metadata
   */
  200: {
    status: string;
    data: {
      assets: Array<{
        policyId: string;
        assetName: string;
        agentIdentifier: string;
        metadata: {
          name: string;
          description?: string | null;
          api_url: string;
          example_output?: string | null;
          tags: Array<string>;
          requests_per_hour?: string | null;
          capability: {
            name: string;
            version: string;
          };
          author: {
            name: string;
            contact?: string | null;
            organization?: string | null;
          };
          legal?: {
            privacy_policy?: string | null;
            terms?: string | null;
            other?: string | null;
          } | null;
          pricing: Array<{
            quantity: number;
            unit: string;
          }>;
          image: string;
          metadata_version: number;
        };
      }>;
    };
  };
};

export type GetRegistryResponse =
  GetRegistryResponses[keyof GetRegistryResponses];

export type PostRegistryData = {
  body?: {
    /**
     * The Cardano network used to register the agent on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The smart contract address of the payment contract to be registered for
     */
    smartContractAddress?: string;
    /**
     * The payment key of a specific wallet used for the registration
     */
    sellingWalletVkey: string;
    /**
     * Link to a example output of the agent
     */
    example_output?: string;
    /**
     * Tags used in the registry metadata
     */
    tags: Array<string>;
    /**
     * Name of the agent
     */
    name: string;
    /**
     * Base URL of the agent, to request interactions
     */
    api_url: string;
    /**
     * Description of the agent
     */
    description: string;
    /**
     * Provide information about the used AI model and version
     */
    capability: {
      name: string;
      version: string;
    };
    /**
     * The request the agent can handle per hour
     */
    requests_per_hour: string;
    /**
     * Price for a default interaction
     */
    pricing: Array<{
      unit: string;
      quantity: string;
    }>;
    /**
     * Legal information about the agent
     */
    legal?: {
      privacy_policy?: string;
      terms?: string;
      other?: string;
    };
    /**
     * Author information about the agent
     */
    author: {
      name: string;
      contact?: string;
      organization?: string;
    };
  };
  path?: never;
  query?: never;
  url: '/registry/';
};

export type PostRegistryResponses = {
  /**
   * Agent registered
   */
  200: {
    status: string;
    data: {
      name: string;
      api_url: string;
      capability_name: string;
      capability_version: string;
      description: string | null;
      requests_per_hour: string | null;
      privacy_policy: string | null;
      terms: string | null;
      other: string | null;
      tags: Array<string>;
      state:
        | 'RegistrationRequested'
        | 'RegistrationInitiated'
        | 'RegistrationConfirmed'
        | 'RegistrationFailed'
        | 'DeregistrationRequested'
        | 'DeregistrationInitiated'
        | 'DeregistrationConfirmed'
        | 'DeregistrationFailed';
      SmartContractWallet: {
        walletVkey: string;
        walletAddress: string;
      };
      Pricing: Array<{
        unit: string;
        quantity: string;
      }>;
    };
  };
};

export type PostRegistryResponse =
  PostRegistryResponses[keyof PostRegistryResponses];

export type DeletePaymentSourceData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The id of the payment source to be deleted
     */
    id: string;
  };
  url: '/payment-source/';
};

export type DeletePaymentSourceResponses = {
  /**
   * Payment source deleted
   */
  200: {
    status: string;
    data: {
      id: string;
    };
  };
};

export type DeletePaymentSourceResponse =
  DeletePaymentSourceResponses[keyof DeletePaymentSourceResponses];

export type GetPaymentSourceData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The number of payment sources to return
     */
    take?: number;
    /**
     * Used to paginate through the payment sources
     */
    cursorId?: string;
  };
  url: '/payment-source/';
};

export type GetPaymentSourceResponses = {
  /**
   * Payment source status
   */
  200: {
    status: string;
    data: {
      paymentSources: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
        lastIdentifierChecked: string | null;
        lastCheckedAt: string | null;
        AdminWallets: Array<{
          walletAddress: string;
          order: number;
        }>;
        PurchasingWallets: Array<{
          id: string;
          walletVkey: string;
          walletAddress: string;
          collectionAddress: string | null;
          note: string | null;
        }>;
        SellingWallets: Array<{
          id: string;
          walletVkey: string;
          walletAddress: string;
          collectionAddress: string | null;
          note: string | null;
        }>;
        FeeReceiverNetworkWallet: {
          walletAddress: string;
        };
        feeRatePermille: number;
      }>;
    };
  };
};

export type GetPaymentSourceResponse =
  GetPaymentSourceResponses[keyof GetPaymentSourceResponses];

export type PatchPaymentSourceData = {
  body?: {
    /**
     * The id of the payment source to be updated
     */
    id: string;
    PaymentSourceConfig?: {
      /**
       * The rpc provider (blockfrost) api key to be used for the payment source
       */
      rpcProviderApiKey: string;
      /**
       * The rpc provider to be used for the payment contract
       */
      rpcProvider: 'Blockfrost';
    };
    /**
     * The mnemonic of the purchasing wallets to be added
     */
    AddPurchasingWallets?: Array<{
      walletMnemonic: string;
      note: string;
      /**
       * The collection address of the purchasing wallet
       */
      collectionAddress: string | null;
    }>;
    /**
     * The mnemonic of the selling wallets to be added
     */
    AddSellingWallets?: Array<{
      walletMnemonic: string;
      note: string;
      /**
       * The collection address of the selling wallet
       */
      collectionAddress: string | null;
    }>;
    /**
     * The ids of the purchasing wallets to be removed. Please backup the mnemonic of the old wallet before removing it.
     */
    RemovePurchasingWallets?: Array<{
      id: string;
    }>;
    /**
     * The ids of the selling wallets to be removed. Please backup the mnemonic of the old wallet before removing it.
     */
    RemoveSellingWallets?: Array<{
      id: string;
    }>;
    /**
     * The latest identifier of the payment source. Usually should not be changed
     */
    lastIdentifierChecked?: string | null;
  };
  path?: never;
  query?: never;
  url: '/payment-source/';
};

export type PatchPaymentSourceResponses = {
  /**
   * Payment contract updated
   */
  200: {
    status: string;
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      network: 'Preprod' | 'Mainnet';
      smartContractAddress: string;
      paymentType: 'Web3CardanoV1';
      PaymentSourceConfig: {
        rpcProviderApiKey: string;
        rpcProvider: 'Blockfrost';
      };
      lastIdentifierChecked: string | null;
      syncInProgress: boolean;
      lastCheckedAt: string | null;
      AdminWallets: Array<{
        walletAddress: string;
        order: number;
      }>;
      PurchasingWallets: Array<{
        id: string;
        walletVkey: string;
        walletAddress: string;
        collectionAddress: string | null;
        note: string | null;
      }>;
      SellingWallets: Array<{
        id: string;
        walletVkey: string;
        walletAddress: string;
        collectionAddress: string | null;
        note: string | null;
      }>;
      FeeReceiverNetworkWallet: {
        walletAddress: string;
      };
      feeRatePermille: number;
    };
  };
};

export type PatchPaymentSourceResponse =
  PatchPaymentSourceResponses[keyof PatchPaymentSourceResponses];

export type PostPaymentSourceData = {
  body?: {
    /**
     * The network the payment source will be used on
     */
    network: 'Preprod' | 'Mainnet';
    /**
     * The type of payment source used
     */
    paymentType: 'Web3CardanoV1';
    PaymentSourceConfig: {
      /**
       * The rpc provider (blockfrost) api key to be used for the payment source
       */
      rpcProviderApiKey: string;
      /**
       * The rpc provider to be used for the payment source
       */
      rpcProvider: 'Blockfrost';
    };
    /**
     * The fee in permille to be used for the payment source. The default contract uses 50 (5%)
     */
    feeRatePermille: number | null;
    /**
     * The wallet addresses of the admin wallets (exactly 3)
     */
    AdminWallets: [
      {
        walletAddress: string;
      },
      {
        walletAddress: string;
      },
      {
        walletAddress: string;
      },
    ];
    /**
     * The wallet address of the network fee receiver wallet
     */
    FeeReceiverNetworkWallet: {
      walletAddress: string;
    };
    /**
     * The mnemonic of the purchasing wallets to be added. Please backup the mnemonic of the wallets.
     */
    PurchasingWallets: Array<{
      walletMnemonic: string;
      /**
       * The collection address of the purchasing wallet
       */
      collectionAddress: string | null;
      note: string;
    }>;
    /**
     * The mnemonic of the selling wallets to be added. Please backup the mnemonic of the wallets.
     */
    SellingWallets: Array<{
      walletMnemonic: string;
      /**
       * The collection address of the selling wallet
       */
      collectionAddress: string | null;
      note: string;
    }>;
  };
  path?: never;
  query?: never;
  url: '/payment-source/';
};

export type PostPaymentSourceResponses = {
  /**
   * Payment source created
   */
  200: {
    status: string;
    data: {
      id: string;
      createdAt: string;
      updatedAt: string;
      network: 'Preprod' | 'Mainnet';
      smartContractAddress: string;
      paymentType: 'Web3CardanoV1';
      PaymentSourceConfig: {
        rpcProviderApiKey: string;
        rpcProvider: 'Blockfrost';
      };
      lastIdentifierChecked: string | null;
      syncInProgress: boolean;
      lastCheckedAt: string | null;
      AdminWallets: Array<{
        walletAddress: string;
        order: number;
      }>;
      PurchasingWallets: Array<{
        id: string;
        walletVkey: string;
        walletAddress: string;
        collectionAddress: string | null;
        note: string | null;
      }>;
      SellingWallets: Array<{
        id: string;
        walletVkey: string;
        walletAddress: string;
        collectionAddress: string | null;
        note: string | null;
      }>;
      FeeReceiverNetworkWallet: {
        walletAddress: string;
      };
      feeRatePermille: number;
    };
  };
};

export type PostPaymentSourceResponse =
  PostPaymentSourceResponses[keyof PostPaymentSourceResponses];

export type GetPaymentSourceExtendedData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * The number of payment sources to return
     */
    take?: number;
    /**
     * Used to paginate through the payment sources
     */
    cursorId?: string;
  };
  url: '/payment-source-extended/';
};

export type GetPaymentSourceExtendedResponses = {
  /**
   * Payment source status
   */
  200: {
    status: string;
    data: {
      paymentSources: Array<{
        id: string;
        createdAt: string;
        updatedAt: string;
        network: 'Preprod' | 'Mainnet';
        smartContractAddress: string;
        paymentType: 'Web3CardanoV1';
        PaymentSourceConfig: {
          rpcProviderApiKey: string;
          rpcProvider: 'Blockfrost';
        };
        lastIdentifierChecked: string | null;
        syncInProgress: boolean;
        lastCheckedAt: string | null;
        AdminWallets: Array<{
          walletAddress: string;
          order: number;
        }>;
        PurchasingWallets: Array<{
          id: string;
          walletVkey: string;
          walletAddress: string;
          collectionAddress: string | null;
          note: string | null;
        }>;
        SellingWallets: Array<{
          id: string;
          walletVkey: string;
          walletAddress: string;
          collectionAddress: string | null;
          note: string | null;
        }>;
        FeeReceiverNetworkWallet: {
          walletAddress: string;
        };
        feeRatePermille: number;
      }>;
    };
  };
};

export type GetPaymentSourceExtendedResponse =
  GetPaymentSourceExtendedResponses[keyof GetPaymentSourceExtendedResponses];

export type GetUtxosData = {
  body?: never;
  path?: never;
  query: {
    /**
     * The address to get the UTXOs for
     */
    address: string;
    network: 'Preprod' | 'Mainnet';
    /**
     * The number of UTXOs to get
     */
    count?: number;
    /**
     * The page number to get
     */
    page?: number;
    /**
     * The order to get the UTXOs in
     */
    order?: 'asc' | 'desc';
  };
  url: '/utxos/';
};

export type GetUtxosResponses = {
  /**
   * UTXOs
   */
  200: {
    status: string;
    data: {
      utxos: Array<{
        txHash: string;
        address: string;
        amount: Array<{
          unit: string;
          quantity: number | null;
        }>;
        data_hash?: string;
        inline_datum?: string;
        reference_script_hash?: string;
        output_index: number | null;
        block: string;
      }>;
    };
  };
};

export type GetUtxosResponse = GetUtxosResponses[keyof GetUtxosResponses];

export type GetRpcApiKeysData = {
  body?: never;
  path?: never;
  query?: {
    /**
     * Used to paginate through the rpc provider keys
     */
    cursorId?: string;
    /**
     * The number of rpc provider keys to return
     */
    limit?: number;
  };
  url: '/rpc-api-keys/';
};

export type GetRpcApiKeysResponses = {
  /**
   * Blockfrost keys
   */
  200: {
    rpcProviderKeys: Array<{
      id: string;
      rpcProviderApiKey: string;
      rpcProvider: 'Blockfrost';
      createdAt: string;
      updatedAt: string;
      network: 'Preprod' | 'Mainnet';
    }>;
  };
};

export type GetRpcApiKeysResponse =
  GetRpcApiKeysResponses[keyof GetRpcApiKeysResponses];

export type ClientOptions = {
  baseURL: `${string}://${string}` | (string & {});
};
